package br.eng.strauss.yaxana.compiler;

import java.io.ByteArrayOutputStream;
import java.io.StringReader;
import java.util.Formatter;
import java.util.Locale;
import java.util.Map;

import br.eng.strauss.yaxana.Parsable;
import jasmin.ClassFile;

/**
 * Writes byte code for the compiler and returns the Java class.
 * 
 * @author Burkhard Strauss
 * @since September 2017
 * @see <a href="https://en.wikipedia.org/wiki/Java_bytecode">Java bytecode</a>
 * @see <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode
 *      instruction listings</a>
 */
final class CodeWriter
{

   private static final String CLASSNAME = Function.class.getPackage().getName() + ".Class";

   private static final String OBJECT = Object.class.getName().replace('.', '/');

   private static final String MAP = Map.class.getName().replace('.', '/');

   private static final String STRING = String.class.getName().replace('.', '/');

   private static final String FUNCTION = Function.class.getName().replace('.', '/');

   private final Formatter asm;

   private final String scalar;

   /**
    * Returns a new Instance.
    *
    * @param clasz
    *           the expression class.
    */
   public CodeWriter(final Class<? extends Parsable<?>> clasz)
   {

      this.asm = new Formatter(Locale.US);
      this.scalar = clasz.getName().replace('.', '/');
      asm.format(".class public %s\n", CLASSNAME.replace('.', '/'));
      asm.format(".super %s\n", FUNCTION);
      asm.format("\n");
      asm.format(".method public <init>()V\n");
      asm.format("  aload_0\n");
      asm.format("  invokespecial %s/<init>()V\n", FUNCTION);
      asm.format("  return\n");
      asm.format(".end method\n");
      asm.format("\n");
      asm.format(".method public value(L%s;)V\n", MAP);
      asm.format("  .limit locals 3\n");
      asm.format("  .limit stack 256\n");
   }

   /**
    * Returns the Java class.
    * 
    * @return the Java class.
    */
   public Class<? extends Function<?>> getJavaClass()
   {

      asm.format("  return\n");
      asm.format(".end method\n");
      asm.format("\n");
      final ClassFile classFile = new ClassFile();
      final StringReader reader = new StringReader(asm.toString());
      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
      try
      {
         classFile.readJasmin(reader, "<auto-generated>", true);
         classFile.write(baos);
         final byte[] byteCode = baos.toByteArray();
         return new Loader().load(CLASSNAME, byteCode);
      }
      catch (final Exception e)
      {
         throw new IllegalStateException("unreached", e);
      }
   }

   public void assignment(final String name)
   {

      asm.format("  astore_2\n");
      asm.format("  aload_1\n");
      asm.format("  ldc \"%s\"\n", name);
      asm.format("  aload_2\n");
      asm.format("  invokeinterface %1$s/put(L%2$s;L%2$s;)L%2$s; 3\n", MAP, OBJECT);
   }

   public void add()
   {

      asm.format("  invokevirtual %1$s/add(L%1$s;)L%1$s;\n", scalar);
   }

   public void sub()
   {

      asm.format("  invokevirtual %1$s/sub(L%1$s;)L%1$s;\n", scalar);
   }

   public void mul()
   {

      asm.format("  invokevirtual %1$s/mul(L%1$s;)L%1$s;\n", scalar);
   }

   public void div()
   {

      asm.format("  invokevirtual %1$s/div(L%1$s;)L%1$s;\n", scalar);
   }

   public void ineg()
   {

      asm.format("  ineg\n");
   }

   public void pow()
   {

      asm.format("  invokevirtual %1$s/pow(I)L%1$s;\n", scalar);
   }

   public void neg()
   {

      asm.format("  invokevirtual %1$s/neg()L%1$s;\n", scalar);
   }

   public void sqrt()
   {

      asm.format("  ldc 2\n");
      root();
   }

   public void root()
   {

      asm.format("  invokevirtual %1$s/root(I)L%1$s;\n", scalar);
   }

   public void abs()
   {

      asm.format("  invokevirtual %1$s/abs()L%1$s;\n", scalar);
   }

   public void lookup(final String name)
   {

      asm.format("  aload_1\n");
      asm.format("  ldc \"%s\"\n", name);
      asm.format("  invokestatic %s/get(L%s;L%s;)L%s;\n", FUNCTION, MAP, STRING, OBJECT);
      asm.format("  checkcast %s\n", scalar);
   }

   public void literal(final String number)
   {

      asm.format("  ldc \"%s\"\n", number);
      asm.format("  invokestatic %s/valueOf(L%s;)L%s;\n", scalar, STRING, scalar);
   }

   public void index()
   {

      asm.format("  invokevirtual %1$s/intValue()I\n", scalar);
   }
}
